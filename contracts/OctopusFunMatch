//Contract based on [https://docs.openzeppelin.com/contracts/3.x/erc721](https://docs.openzeppelin.com/contracts/3.x/erc721)
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
// import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract OctopusFunMatch is ERC721URIStorage {//, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("OctopusFun", "OCF") {}


    // Basic gameplay
    // - Keep a list of all alive & dead tokens. Populate in Round 1.
    // - Each round has a specific start and end time. If you fail to participate in any week, your NFT is automatically eliminated
    // - Check each round if there's only 1 alive. If so, pay out. (Guaranteed winner)
    // - At the end of round 6, pay out to all alive

    function round1(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

    function round2(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

    function round3(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

    function round4(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

    function round5(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

    function round6(address recipient, string memory tokenURI)
        external
        payable
        returns (uint256)
    {
        // Random game generator
    }

}

